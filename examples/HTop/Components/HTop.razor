@namespace HTop.Components

@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Web
@using RazorConsole.Components
@using Spectre.Console
@using System.Diagnostics
@using System.Runtime.InteropServices

@implements IDisposable

@if (_cpuCores.Count > 0)
{
    <SystemHeader CpuCores="@_cpuCores"
                  UsedMemoryMB="@_usedMemoryMB"
                  TotalMemoryMB="@_totalMemoryMB"
                  SwapUsedMB="@_swapUsedMB"
                  SwapTotalMB="@_swapTotalMB"
                  ProcessCount="@_processCount"
                  RunningCount="@_runningCount"
                  RunningProcesses="@_runningProcesses"
                  LoadAverage="@_loadAverage"
                  Uptime="@_uptime" />
    <ProcessTable Processes="@_displayProcesses"
                  OnSortColumnChanged="SetSortColumn" />
    <FunctionKeyBar />
}
else
{
    <Markup Content="Initializing..." Foreground="@Color.Yellow" />
}

@code {
    private Timer? _updateTimer;
    private List<double> _cpuCores = Enumerable.Repeat(0.0, Environment.ProcessorCount).ToList();
    private long _usedMemoryMB;
    private long _totalMemoryMB;
    private long _swapUsedMB = 0;
    private long _swapTotalMB = 8099;
    private int _processCount;
    private int _runningCount;
    private int _runningProcesses;
    private string _loadAverage = "0.00 0.00 0.00";
    private string _uptime = string.Empty;
    private List<ProcessTable.ProcessInfo> _displayProcesses = new();
    private string _sortColumn = "CPU";
    private readonly DateTime _startTime = DateTime.Now;
    
    // For CPU calculation
    private readonly Dictionary<int, (DateTime Time, TimeSpan TotalProcessorTime)> _previousCpuUsage = new();

    protected override void OnInitialized()
    {        
        UpdateMetrics();
        _updateTimer = new Timer(async _ =>
        {
            UpdateMetrics();
            await InvokeAsync(StateHasChanged);
        }, null, TimeSpan.FromSeconds(2), TimeSpan.FromSeconds(2));
    }

    private void UpdateMetrics()
    {
        try
        {
            // Update uptime
            var uptime = DateTime.Now - _startTime;
            if (uptime.TotalDays >= 1)
                _uptime = $"{(int)uptime.TotalDays} day, {uptime.Hours:D2}:{uptime.Minutes:D2}:{uptime.Seconds:D2}";
            else
                _uptime = $"{uptime.Hours:D2}:{uptime.Minutes:D2}:{uptime.Seconds:D2}";

            // Get memory info
            var gcMemoryInfo = GC.GetGCMemoryInfo();
            _totalMemoryMB = gcMemoryInfo.TotalAvailableMemoryBytes / (1024 * 1024);
            
            // Calculate used memory and process info
            var processes = Process.GetProcesses();
            _processCount = processes.Length;
            long totalUsedMemory = 0;
            int runningProcesses = 0;
            int totalThreads = 0;
            
            var processList = new List<ProcessTable.ProcessInfo>();

            foreach (var process in processes)
            {
                try
                {
                    var memoryBytes = process.WorkingSet64;
                    totalUsedMemory += memoryBytes;
                    
                    // Calculate CPU usage
                    var cpuPercent = CalculateCpuUsage(process);
                    
                    // Count running processes
                    if (cpuPercent > 0 || !process.Responding)
                        runningProcesses++;
                    
                    // Count threads
                    try { totalThreads += process.Threads.Count; } catch { }

                    // Get user name
                    string userName = "user";
                    try
                    {
                        userName = process.StartInfo?.UserName ?? Environment.UserName;
                    }
                    catch { }

                    // Get process state
                    string state = "S"; // Sleeping
                    if (cpuPercent > 0) state = "R"; // Running
                    if (!process.Responding) state = "D"; // Uninterruptible sleep

                    processList.Add(new ProcessTable.ProcessInfo
                    {
                        Id = process.Id,
                        User = userName,
                        Priority = 20, // Default priority (simplified)
                        Nice = 0, // Default nice value
                        VirtualMemory = FormatMemory(process.VirtualMemorySize64),
                        ResidentMemory = FormatMemory(memoryBytes),
                        State = state,
                        CpuPercent = cpuPercent,
                        MemPercent = _totalMemoryMB > 0 ? (memoryBytes / (1024.0 * 1024.0) / _totalMemoryMB) * 100 : 0,
                        CpuTime = FormatCpuTime(process.TotalProcessorTime),
                        Command = process.ProcessName
                    });
                }
                catch
                {
                    // Process may have exited or we don't have access
                }
            }

            _usedMemoryMB = totalUsedMemory / (1024 * 1024);
            _runningCount = totalThreads;
            _runningProcesses = runningProcesses;

            // Simulate swap (not easily accessible in .NET)
            _swapTotalMB = 8099;
            _swapUsedMB = 0;

            // Simulate load average (not easily accessible in .NET on all platforms)
            var topCpu = processList.OrderByDescending(p => p.CpuPercent).Take(3).ToList();
            var load1 = topCpu.Count > 0 ? topCpu[0].CpuPercent / 10.0 : 0;
            var load5 = topCpu.Count > 1 ? topCpu[1].CpuPercent / 10.0 : 0;
            var load15 = topCpu.Count > 2 ? topCpu[2].CpuPercent / 10.0 : 0;
            _loadAverage = $"{load1:F2} {load5:F2} {load15:F2}";

            // Simulate per-core CPU usage (simplified)
            var totalCpu = processList.Sum(p => p.CpuPercent);
            var avgPerCore = totalCpu / Environment.ProcessorCount;
            for (int i = 0; i < _cpuCores.Count; i++)
            {
                // Add some variation
                _cpuCores[i] = Math.Min(100, avgPerCore * (0.8 + (i * 0.1)));
            }

            // Sort and take top 20 processes
            _displayProcesses = SortProcesses(processList).Take(20).ToList();
        }
        catch (Exception)
        {
            // Silently handle any errors
        }
    }

    private double CalculateCpuUsage(Process process)
    {
        try
        {
            var currentTime = DateTime.Now;
            var currentCpuTime = process.TotalProcessorTime;

            if (_previousCpuUsage.TryGetValue(process.Id, out var previous))
            {
                var timeDiff = (currentTime - previous.Time).TotalMilliseconds;
                var cpuDiff = (currentCpuTime - previous.TotalProcessorTime).TotalMilliseconds;
                
                if (timeDiff > 0)
                {
                    var cpuUsagePercent = (cpuDiff / (timeDiff * Environment.ProcessorCount)) * 100;
                    _previousCpuUsage[process.Id] = (currentTime, currentCpuTime);
                    return Math.Min(cpuUsagePercent, 100); // Cap at 100%
                }
            }

            _previousCpuUsage[process.Id] = (currentTime, currentCpuTime);
            return 0;
        }
        catch
        {
            return 0;
        }
    }

    private static string FormatMemory(long bytes)
    {
        if (bytes < 1024) return $"{bytes}";
        if (bytes < 1024 * 1024) return $"{bytes / 1024}K";
        if (bytes < 1024 * 1024 * 1024) return $"{bytes / (1024 * 1024)}M";
        return $"{bytes / (1024 * 1024 * 1024)}G";
    }

    private static string FormatCpuTime(TimeSpan time)
    {
        if (time.TotalHours >= 1)
            return $"{(int)time.TotalHours}:{time.Minutes:D2}:{time.Seconds:D2}";
        return $"{time.Minutes}:{time.Seconds:D2}.{time.Milliseconds / 10:D2}";
    }

    private List<ProcessTable.ProcessInfo> SortProcesses(List<ProcessTable.ProcessInfo> processes)
    {
        return _sortColumn switch
        {
            "PID" => processes.OrderBy(p => p.Id).ToList(),
            "USER" => processes.OrderBy(p => p.User).ToList(),
            "PRI" => processes.OrderByDescending(p => p.Priority).ToList(),
            "NI" => processes.OrderBy(p => p.Nice).ToList(),
            "VIRT" => processes.OrderByDescending(p => p.VirtualMemory).ToList(),
            "RES" => processes.OrderByDescending(p => p.ResidentMemory).ToList(),
            "S" => processes.OrderBy(p => p.State).ToList(),
            "CPU" => processes.OrderByDescending(p => p.CpuPercent).ToList(),
            "MEM" => processes.OrderByDescending(p => p.MemPercent).ToList(),
            "TIME" => processes.OrderByDescending(p => p.CpuTime).ToList(),
            "Command" => processes.OrderBy(p => p.Command).ToList(),
            _ => processes.OrderByDescending(p => p.CpuPercent).ToList()
        };
    }

    private void SetSortColumn(string column)
    {
        _sortColumn = column;
        // Re-sort existing processes immediately, next timer update will refresh data
        _displayProcesses = SortProcesses(_displayProcesses).ToList();
    }

    public void Dispose()
    {
        _updateTimer?.Dispose();
    }
}

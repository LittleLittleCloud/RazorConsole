@namespace HTop.Components

@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Web
@using RazorConsole.Components
@using Spectre.Console
@using System.Diagnostics
@using System.Runtime.InteropServices

@implements IDisposable

@if (_cpuCores.Count > 0)
{
    @* Header with CPU bars and system info *@
    <Columns>
        <div>
            <Rows>
                @for (int i = 0; i < _cpuCores.Count; i++)
                {
                    var cpuIndex = i; // Capture for closure
                    <Columns>
                        <Markup Content="@($"{cpuIndex + 1,2}")" Foreground="@Color.Aqua" />
                        <Markup Content="@BuildCpuBar(_cpuCores[cpuIndex])" />
                        <Markup Content="@($"{_cpuCores[cpuIndex],5:F1}%")" Foreground="@Color.Grey70" />
                    </Columns>
                }
                <Columns>
                    <Markup Content="Mem" Foreground="@Color.Aqua" />
                    <Markup Content="@BuildMemoryBar()" />
                    <Markup Content="@($"{_usedMemoryMB,4}/{_totalMemoryMB}MB")" Foreground="@Color.Grey70" />
                </Columns>
                <Columns>
                    <Markup Content="Swp" Foreground="@Color.Aqua" />
                    <Markup Content="@BuildSwapBar()" />
                    <Markup Content="@($"{_swapUsedMB,4}/{_swapTotalMB}MB")" Foreground="@Color.Grey70" />
                </Columns>
            </Rows>
        </div>
        <div>
            <Rows>
                <Markup Content="@($"Tasks: {_processCount}, {_runningCount} thr; {_runningProcesses} running")" Foreground="@Color.Aqua" />
                <Markup Content="@($"Load average: {_loadAverage}")" Foreground="@Color.Aqua" />
                <Markup Content="@($"Uptime: {_uptime}")" Foreground="@Color.Aqua" />
            </Rows>
        </div>
    </Columns>

    <Newline />

    @* Process table without border *@
    <SpectreTable Expand="true" Border="TableBorder.None">
    <SpectreTHead>
        <SpectreTR>
            <SpectreTH Align="Justify.Right">
                <TextButton Content="PID"
                            OnClick="@(() => SetSortColumn("PID"))"
                            BackgroundColor="@Color.Green"
                            FocusedColor="@Color.Blue" />
            </SpectreTH>
            <SpectreTH Align="Justify.Left">
                <TextButton Content="USER"
                            OnClick="@(() => SetSortColumn("USER"))"
                            BackgroundColor="@Color.Green"
                            FocusedColor="@Color.Blue" />
            </SpectreTH>
            <SpectreTH Align="Justify.Right">
                <TextButton Content="PRI"
                            OnClick="@(() => SetSortColumn("PRI"))"
                            BackgroundColor="@Color.Green"
                            FocusedColor="@Color.Blue" />
            </SpectreTH>
            <SpectreTH Align="Justify.Right">
                <TextButton Content="NI"
                            OnClick="@(() => SetSortColumn("NI"))"
                            BackgroundColor="@Color.Green"
                            FocusedColor="@Color.Blue" />
            </SpectreTH>
            <SpectreTH Align="Justify.Right">
                <TextButton Content="VIRT"
                            OnClick="@(() => SetSortColumn("VIRT"))"
                            BackgroundColor="@Color.Green"
                            FocusedColor="@Color.Blue" />
            </SpectreTH>
            <SpectreTH Align="Justify.Right">
                <TextButton Content="RES"
                            OnClick="@(() => SetSortColumn("RES"))"
                            BackgroundColor="@Color.Green"
                            FocusedColor="@Color.Blue" />
            </SpectreTH>
            <SpectreTH Align="Justify.Center">
                <TextButton Content="S"
                            OnClick="@(() => SetSortColumn("S"))"
                            BackgroundColor="@Color.Green"
                            FocusedColor="@Color.Blue" />
            </SpectreTH>
            <SpectreTH Align="Justify.Right">
                <TextButton Content="CPU%"
                            OnClick="@(() => SetSortColumn("CPU"))"
                            BackgroundColor="@Color.Green"
                            FocusedColor="@Color.Blue" />
            </SpectreTH>
            <SpectreTH Align="Justify.Right">
                <TextButton Content="MEM%"
                            OnClick="@(() => SetSortColumn("MEM"))"
                            BackgroundColor="@Color.Green"
                            FocusedColor="@Color.Blue" />
            </SpectreTH>
            <SpectreTH Align="Justify.Right">
                <TextButton Content="TIME+"
                            OnClick="@(() => SetSortColumn("TIME"))"
                            BackgroundColor="@Color.Green"
                            FocusedColor="@Color.Blue" />
            </SpectreTH>
            <SpectreTH Align="Justify.Left">
                <TextButton Content="Command"
                            OnClick="@(() => SetSortColumn("Command"))"
                            BackgroundColor="@Color.Green"
                            FocusedColor="@Color.Blue" />
            </SpectreTH>
        </SpectreTR>
    </SpectreTHead>
    <SpectreTBody>
        @foreach (var process in _displayProcesses)
        {
            <SpectreTR>
                <SpectreTD>
                    <Markup Content="@process.Id.ToString()" Foreground="@Color.White" />
                </SpectreTD>
                <SpectreTD>
                    <Markup Content="@process.User" Foreground="@Color.White" />
                </SpectreTD>
                <SpectreTD>
                    <Markup Content="@process.Priority.ToString()" Foreground="@Color.White" />
                </SpectreTD>
                <SpectreTD>
                    <Markup Content="@process.Nice.ToString()" Foreground="@(process.Nice < 0 ? Color.Red : Color.White)" />
                </SpectreTD>
                <SpectreTD>
                    <Markup Content="@process.VirtualMemory" Foreground="@Color.Aqua" />
                </SpectreTD>
                <SpectreTD>
                    <Markup Content="@process.ResidentMemory" Foreground="@Color.Aqua" />
                </SpectreTD>
                <SpectreTD>
                    <Markup Content="@process.State" Foreground="@GetStateColor(process.State)" />
                </SpectreTD>
                <SpectreTD>
                    <Markup Content="@($"{process.CpuPercent:F1}")" Foreground="@GetProcessCpuColor(process.CpuPercent)" />
                </SpectreTD>
                <SpectreTD>
                    <Markup Content="@($"{process.MemPercent:F1}")" Foreground="@Color.White" />
                </SpectreTD>
                <SpectreTD>
                    <Markup Content="@process.CpuTime" Foreground="@Color.White" />
                </SpectreTD>
                <SpectreTD>
                    <Markup Content="@process.Command" Foreground="@Color.White" />
                </SpectreTD>
            </SpectreTR>
        }
    </SpectreTBody>
    </SpectreTable>

    <Newline />
    @* Function keys *@
    <Markup Content="[green]F1[/]Help [green]F2[/]Setup [green]F3[/]Search [green]F4[/]Filter [green]F5[/]Tree [green]F6[/]SortBy [green]F7[/]Nice [green]F8[/]Nice+ [green]F9[/]Kill [green]F10[/]Quit" />
}
else
{
    <Markup Content="Initializing..." Foreground="@Color.Yellow" />
}

@code {
    private class ProcessInfo
    {
        public int Id { get; set; }
        public string User { get; set; } = string.Empty;
        public int Priority { get; set; }
        public int Nice { get; set; }
        public string VirtualMemory { get; set; } = string.Empty;
        public string ResidentMemory { get; set; } = string.Empty;
        public string State { get; set; } = string.Empty;
        public double CpuPercent { get; set; }
        public double MemPercent { get; set; }
        public string CpuTime { get; set; } = string.Empty;
        public string Command { get; set; } = string.Empty;
    }

    private Timer? _updateTimer;
    private List<double> _cpuCores = Enumerable.Repeat(0.0, Environment.ProcessorCount).ToList();
    private long _usedMemoryMB;
    private long _totalMemoryMB;
    private long _swapUsedMB = 0;
    private long _swapTotalMB = 8099;
    private int _processCount;
    private int _runningCount;
    private int _runningProcesses;
    private string _loadAverage = "0.00 0.00 0.00";
    private string _uptime = string.Empty;
    private List<ProcessInfo> _displayProcesses = new();
    private string _sortColumn = "CPU";
    private readonly DateTime _startTime = DateTime.Now;
    
    // For CPU calculation
    private readonly Dictionary<int, (DateTime Time, TimeSpan TotalProcessorTime)> _previousCpuUsage = new();

    protected override void OnInitialized()
    {        
        UpdateMetrics();
        _updateTimer = new Timer(async _ =>
        {
            UpdateMetrics();
            await InvokeAsync(StateHasChanged);
        }, null, TimeSpan.FromSeconds(2), TimeSpan.FromSeconds(2));
    }

    private void UpdateMetrics()
    {
        try
        {
            // Update uptime
            var uptime = DateTime.Now - _startTime;
            if (uptime.TotalDays >= 1)
                _uptime = $"{(int)uptime.TotalDays} day, {uptime.Hours:D2}:{uptime.Minutes:D2}:{uptime.Seconds:D2}";
            else
                _uptime = $"{uptime.Hours:D2}:{uptime.Minutes:D2}:{uptime.Seconds:D2}";

            // Get memory info
            var gcMemoryInfo = GC.GetGCMemoryInfo();
            _totalMemoryMB = gcMemoryInfo.TotalAvailableMemoryBytes / (1024 * 1024);
            
            // Calculate used memory and process info
            var processes = Process.GetProcesses();
            _processCount = processes.Length;
            long totalUsedMemory = 0;
            int runningProcesses = 0;
            int totalThreads = 0;
            
            var processList = new List<ProcessInfo>();

            foreach (var process in processes)
            {
                try
                {
                    var memoryBytes = process.WorkingSet64;
                    totalUsedMemory += memoryBytes;
                    
                    // Calculate CPU usage
                    var cpuPercent = CalculateCpuUsage(process);
                    
                    // Count running processes
                    if (cpuPercent > 0 || !process.Responding)
                        runningProcesses++;
                    
                    // Count threads
                    try { totalThreads += process.Threads.Count; } catch { }

                    // Get user name
                    string userName = "user";
                    try
                    {
                        userName = process.StartInfo?.UserName ?? Environment.UserName;
                    }
                    catch { }

                    // Get process state
                    string state = "S"; // Sleeping
                    if (cpuPercent > 0) state = "R"; // Running
                    if (!process.Responding) state = "D"; // Uninterruptible sleep

                    processList.Add(new ProcessInfo
                    {
                        Id = process.Id,
                        User = userName,
                        Priority = 20, // Default priority (simplified)
                        Nice = 0, // Default nice value
                        VirtualMemory = FormatMemory(process.VirtualMemorySize64),
                        ResidentMemory = FormatMemory(memoryBytes),
                        State = state,
                        CpuPercent = cpuPercent,
                        MemPercent = _totalMemoryMB > 0 ? (memoryBytes / (1024.0 * 1024.0) / _totalMemoryMB) * 100 : 0,
                        CpuTime = FormatCpuTime(process.TotalProcessorTime),
                        Command = process.ProcessName
                    });
                }
                catch
                {
                    // Process may have exited or we don't have access
                }
            }

            _usedMemoryMB = totalUsedMemory / (1024 * 1024);
            _runningCount = totalThreads;
            _runningProcesses = runningProcesses;

            // Simulate swap (not easily accessible in .NET)
            _swapTotalMB = 8099;
            _swapUsedMB = 0;

            // Simulate load average (not easily accessible in .NET on all platforms)
            var topCpu = processList.OrderByDescending(p => p.CpuPercent).Take(3).ToList();
            var load1 = topCpu.Count > 0 ? topCpu[0].CpuPercent / 10.0 : 0;
            var load5 = topCpu.Count > 1 ? topCpu[1].CpuPercent / 10.0 : 0;
            var load15 = topCpu.Count > 2 ? topCpu[2].CpuPercent / 10.0 : 0;
            _loadAverage = $"{load1:F2} {load5:F2} {load15:F2}";

            // Simulate per-core CPU usage (simplified)
            var totalCpu = processList.Sum(p => p.CpuPercent);
            var avgPerCore = totalCpu / Environment.ProcessorCount;
            for (int i = 0; i < _cpuCores.Count; i++)
            {
                // Add some variation
                _cpuCores[i] = Math.Min(100, avgPerCore * (0.8 + (i * 0.1)));
            }

            // Sort and take top 20 processes
            _displayProcesses = SortProcesses(processList).Take(20).ToList();
        }
        catch (Exception)
        {
            // Silently handle any errors
        }
    }

    private double CalculateCpuUsage(Process process)
    {
        try
        {
            var currentTime = DateTime.Now;
            var currentCpuTime = process.TotalProcessorTime;

            if (_previousCpuUsage.TryGetValue(process.Id, out var previous))
            {
                var timeDiff = (currentTime - previous.Time).TotalMilliseconds;
                var cpuDiff = (currentCpuTime - previous.TotalProcessorTime).TotalMilliseconds;
                
                if (timeDiff > 0)
                {
                    var cpuUsagePercent = (cpuDiff / (timeDiff * Environment.ProcessorCount)) * 100;
                    _previousCpuUsage[process.Id] = (currentTime, currentCpuTime);
                    return Math.Min(cpuUsagePercent, 100); // Cap at 100%
                }
            }

            _previousCpuUsage[process.Id] = (currentTime, currentCpuTime);
            return 0;
        }
        catch
        {
            return 0;
        }
    }

    private static string FormatMemory(long bytes)
    {
        if (bytes < 1024) return $"{bytes}";
        if (bytes < 1024 * 1024) return $"{bytes / 1024}K";
        if (bytes < 1024 * 1024 * 1024) return $"{bytes / (1024 * 1024)}M";
        return $"{bytes / (1024 * 1024 * 1024)}G";
    }

    private static string FormatCpuTime(TimeSpan time)
    {
        if (time.TotalHours >= 1)
            return $"{(int)time.TotalHours}:{time.Minutes:D2}:{time.Seconds:D2}";
        return $"{time.Minutes}:{time.Seconds:D2}.{time.Milliseconds / 10:D2}";
    }

    private string BuildCpuBar(double percentage)
    {
        const int barLength = 25;
        int filled = (int)(percentage / 100.0 * barLength);
        
        var bar = "[";
        for (int i = 0; i < barLength; i++)
        {
            if (i < filled * 0.3)
                bar += "[blue]|[/]";
            else if (i < filled * 0.7)
                bar += "[green]|[/]";
            else if (i < filled)
                bar += "[yellow]|[/]";
            else
                bar += " ";
        }
        bar += "]";
        return bar;
    }

    private string BuildMemoryBar()
    {
        const int barLength = 25;
        double percentage = _totalMemoryMB > 0 ? (_usedMemoryMB / (double)_totalMemoryMB) * 100 : 0;
        int filled = (int)(percentage / 100.0 * barLength);
        
        var bar = "[";
        for (int i = 0; i < barLength; i++)
        {
            if (i < filled * 0.5)
                bar += "[green]|[/]";
            else if (i < filled)
                bar += "[yellow]|[/]";
            else
                bar += " ";
        }
        bar += "]";
        return bar;
    }

    private string BuildSwapBar()
    {
        const int barLength = 25;
        var bar = "[";
        for (int i = 0; i < barLength; i++)
        {
            bar += " ";
        }
        bar += "]";
        return bar;
    }

    private List<ProcessInfo> SortProcesses(List<ProcessInfo> processes)
    {
        return _sortColumn switch
        {
            "PID" => processes.OrderBy(p => p.Id).ToList(),
            "USER" => processes.OrderBy(p => p.User).ToList(),
            "PRI" => processes.OrderByDescending(p => p.Priority).ToList(),
            "NI" => processes.OrderBy(p => p.Nice).ToList(),
            "VIRT" => processes.OrderByDescending(p => p.VirtualMemory).ToList(),
            "RES" => processes.OrderByDescending(p => p.ResidentMemory).ToList(),
            "S" => processes.OrderBy(p => p.State).ToList(),
            "CPU" => processes.OrderByDescending(p => p.CpuPercent).ToList(),
            "MEM" => processes.OrderByDescending(p => p.MemPercent).ToList(),
            "TIME" => processes.OrderByDescending(p => p.CpuTime).ToList(),
            "Command" => processes.OrderBy(p => p.Command).ToList(),
            _ => processes.OrderByDescending(p => p.CpuPercent).ToList()
        };
    }

    private void SetSortColumn(string column)
    {
        _sortColumn = column;
        // Re-sort existing processes immediately, next timer update will refresh data
        _displayProcesses = SortProcesses(_displayProcesses).ToList();
    }

    private static Color GetProcessCpuColor(double cpuPercent)
    {
        if (cpuPercent > 50) return Color.Red;
        if (cpuPercent > 20) return Color.Yellow;
        return Color.Green;
    }

    private static Color GetStateColor(string state)
    {
        return state switch
        {
            "R" => Color.Green, // Running
            "S" => Color.White, // Sleeping
            "D" => Color.Red,   // Uninterruptible sleep
            _ => Color.Grey
        };
    }

    public void Dispose()
    {
        _updateTimer?.Dispose();
    }
}

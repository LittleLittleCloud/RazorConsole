/**
 * WASM Loader for RazorConsole Gallery
 * 
 * This module handles loading and initializing the RazorConsole.Gallery WASM module,
 * and provides an interface for bidirectional communication between the browser and
 * the .NET WASM runtime.
 */

export interface WasmModule {
  sendInput: (input: string) => void;
  sendKeyPress: (key: string) => void;
  dispose: () => void;
}

export interface WasmCallbacks {
  onOutput?: (data: string) => void;
  onError?: (error: string) => void;
  onReady?: () => void;
}

/**
 * Loads the RazorConsole.Gallery WASM module
 * @param callbacks Callbacks for handling WASM events
 * @returns Promise that resolves to a WasmModule interface
 */
export async function loadWasmModule(callbacks: WasmCallbacks): Promise<WasmModule> {
  const { onOutput, onError, onReady } = callbacks;

  try {
    // For demo/development: show mock output
    // To load the main.ts module from WASM bundle:
    // const wasmBaseUrl = new URL('./', getWasmBundleUrl())
    // const mainModuleUrl = new URL('./main.ts', wasmBaseUrl).href
    // In production, this would:
    // 1. Load the main.ts module: const { initRazorConsole, onConsoleOutput } = await import(mainModuleUrl)
    // 2. Set up console output capture: onConsoleOutput(onOutput)
    // 3. Initialize WASM: const wasmModule = await initRazorConsole()
    // 4. Return the module with sendKey method
    
    // Show demo output
    if (onOutput) {
      onOutput("\x1b[1;32mâœ“ RazorConsole.Gallery - Browser WASM Support\x1b[0m\r\n");
      onOutput("\r\n");
      onOutput("WASM infrastructure is ready. To complete integration:\r\n");
      onOutput("\r\n");
      onOutput("\x1b[36m1. Copy AppBundle to public/wasm/\x1b[0m\r\n");
      onOutput("   dotnet build -f net10.0-browser\r\n");
      onOutput("   cp -r artifacts/.../AppBundle/* website/public/wasm/\r\n");
      onOutput("\r\n");
      onOutput("\x1b[36m2. Load main.ts module\x1b[0m\r\n");
      onOutput("   const { initRazorConsole } = await import('/wasm/main.ts')\r\n");
      onOutput("\r\n");
      onOutput("\x1b[36m3. Forward keyboard events\x1b[0m\r\n");
      onOutput("   wasmModule.sendKey(event.key, shift, ctrl, alt)\r\n");
      onOutput("\r\n");
      onOutput("See website/WASM_BUILD.md for full instructions.\r\n");
      onOutput("\r\n");
    }
    
    // Notify ready
    if (onReady) {
      onReady();
    }
    
    return {
      sendInput: (input: string) => {
        // In production: wasmModule.sendKey(input, false, false, false)
        if (onOutput) {
          onOutput(input);
        }
      },
      sendKeyPress: (key: string) => {
        // In production: wasmModule.sendKey(key, event.shiftKey, event.ctrlKey, event.altKey)
        console.log("Key pressed:", key);
      },
      dispose: () => {
        console.log("Disposing WASM module");
      },
    };
  } catch (error) {
    if (onError) {
      onError(error instanceof Error ? error.message : "Unknown error loading WASM");
    }
    throw error;
  }
}

/**
 * Gets the URL for the WASM bundle
 * This should point to the AppBundle generated by the .NET build
 */
export function getWasmBundleUrl(): string {
  // Use environment variable or default to production path
  const basePath = import.meta.env.BASE_URL || '/';
  return `${basePath}wasm/_framework/dotnet.js`;
}

/**
 * Checks if WASM is supported in the current browser
 */
export function isWasmSupported(): boolean {
  try {
    if (typeof WebAssembly === "object" &&
        typeof WebAssembly.instantiate === "function") {
      const module = new WebAssembly.Module(Uint8Array.of(0x0, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00));
      if (module instanceof WebAssembly.Module) {
        return new WebAssembly.Instance(module) instanceof WebAssembly.Instance;
      }
    }
  } catch (e) {
    // WebAssembly not supported
  }
  return false;
}
